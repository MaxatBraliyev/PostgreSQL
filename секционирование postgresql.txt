Процедура партицирования через наследование
1. Создаём таблицы-партиции с использованием ключевого слова INHERITS:

CREATE TABLE bigtable_y2021m03 (   
    CHECK (created_at >= '2021-03-01'::DATE AND created_at < '2021-04-01'::DATE) 
  ) INHERITS (bigtable);
CREATE TABLE bigtable_y2021m04 (    
    CHECK (created_at >= '2021-04-01'::DATE AND created_at < '2021-05-01'::DATE)  
  ) INHERITS (bigtable);
Указываем уникальное имя таблицы-партиции. Желательно в имени кратно указать критерий (условие) партицирования. Задаём критерий партицирования для каждой партиции через CHECK. Обратите внимание, условия для партиций должны быть уникальны, вставляемая строка данных должна удовлетворять условию только одной партиции. Поэтому в данном примере нижняя граница условия имеет знак нестрогого неравенства, а верхняя граница — строгого.

Если планируется разнести имеющиеся в мастер-таблице данные по партициям, то в данном шаге создаём столько партиций, сколько необходимо, чтобы покрыть ими текущие данные плюс некоторое количество партиций для будущих данных на 2-3 месяца вперёд. Иначе создаём партиции только для будущих данных.

2. Добавляем индексы, такие же, как в мастер-таблице:

ALTER TABLE ONLY bigtable_y2021m03    
    ADD CONSTRAINT bigtable_y2021m03__pkey PRIMARY KEY (id);
CREATE INDEX bigtable_y2021m03__created_at ON bigtable_y2021m03 (created_at);
ALTER TABLE ONLY bigtable_y2021m04  
    ADD CONSTRAINT bigtable_y2021m04__pkey PRIMARY KEY (id);
CREATE INDEX bigtable_y2021m04__created_at ON bigtable_y2021m04 (created_at);
3. Создаём функцию, обеспечивающую партицирование:

CREATE OR REPLACE FUNCTION     
    bigtable_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
IF ( NEW.created_at >= '2021-03-01'::DATE AND 
    NEW.created_at < '2021-04-01'::DATE ) THEN    
        INSERT INTO bigtable_y2021m03 VALUES (NEW.*);
ELSIF ( NEW.created_at >= '2021-04-01'::DATE AND   
    NEW.created_at < '2021-05-01'::DATE ) THEN  
        INSERT INTO bigtable_y2021m04 VALUES (NEW.);
ELSE
    RAISE EXCEPTION 'Date out of range.   
        Fix the bigtable_insert_trigger() function!';
END IF;
RETURN NULL;
END;
$$
LANGUAGE plpgsql;
Цель данной функции — определение партиции, в которую будет вставлена новая строка, на основе заданных условий партицирования. Если такое условие найдено не будет, функция сгенерирует ошибку о невозможности выполнения подобной операции.

4. Подключаем функцию к мастер-таблице:

CREATE TRIGGER insert_bigtable    
    BEFORE INSERT ON bigtable
    FOR EACH ROW EXECUTE FUNCTION bigtable_insert_trigger();
Ключевой шаг. Триггер обеспечивает вставку данных в правильную партицию. При выборке данных PostgreSQL самостоятельно определяет, из каких партиций брать данные.

5. Разносим данные из мастер-таблицы по партициям:

WITH x AS (  
    DELETE FROM ONLY bigtable      
        WHERE created_at BETWEEN .. AND .. RETURNING *)
INSERT INTO bigtable_y20XXmYY   
    SELECT * FROM x;
Итерационно по условию WHERE удаляем данные из мастер-таблицы и удалённые данные возвращаем (RETURNING) в качестве ответа на запрос DELETE FROM. Эти данные используем для вставки в нужную партицию. Обратите внимание на ключевое слово ONLY в операции удаления: без него запрос отработает не только по мастер-таблице, но и по всем партициям. Данное ключевое слово может быть полезно и при выборке данных ТОЛЬКО из мастер-таблицы, и при прочих операциях с мастер-таблицей, если не хотим, чтобы были затронуты партиции.

Если планируется полностью удалить данные из мастер-таблицы без переноса, то пропускаем данный шаг.

6. Очищаем мастер-таблицу

TRUNCATE ONLY bigtable;
Здесь снова используем ключевое слово ONLY, таким образом данные в партициях затронуты не будут. В процессе работы запроса для мастер-таблицы будут созданы новые пустые дата-файлы и пустые файлы индексов, прежние файлы мастер-таблицы будут удалены. В данном шаге можно было бы использовать полный вакуум, однако, в отличие от TRUNCATE операция полного вакуума выполняет проверку на существование данных, что даже на формально пустой таблице может вызвать значительный простой.

Отлично, партицирование выполнено, всё работает.

Проходит три месяца, новые данные перестают писаться в таблицу. Всё потому, что мы забыли добавить в крон добавление новых партиций. Быстро лечим кроном и переписываем функцию (добавляем условия проверки). Через год у нас уже 100 партиций, и функция разрослась до неимоверных размеров. Обслуживать такую таблицу со временем стало сложнее. Давайте не будем так делать и вместо этого заставим PostgreSQL самостоятельно решать подобные проблемы.

Объединим первые три шага процедуры в один. В итоге получим следующую процедуру:

1. Создаём расширенную функцию, обеспечивающую партицирование с автоматическим созданием партиций:

CREATE OR REPLACE FUNCTION bigtable_insert_trigger()
RETURNS TRIGGER AS $$
DECLARE
  current_date_part DATE;
  current_date_part_id TEXT;
  partition_table_name TEXT;
  first_day_of_month DATE;
  last_day_of_month DATE;
BEGIN
  current_date_part := CAST(DATE_TRUNC('month', NEW.created_at) AS DATE);
  current_date_part_text := REGEXP_REPLACE(current_date_part::TEXT, '-','_','g');
  partition_table_name := FORMAT('bigtable_%s', current_date_part_text::TEXT);
  IF (TO_REGCLASS(partition_table_name::TEXT) ISNULL) THEN
    first_day_of_month := current_date_part;
    last_day_of_month := current_date_part + '1 month'::INTERVAL;
    EXECUTE FORMAT(
      'CREATE TABLE %I ('
      '  CHECK (created_at >= DATE %L AND created_at < DATE %L)'
      ') INHERITS (bigtable);'
      , partition_table_name, first_day_of_month, last_day_of_month);
    EXECUTE FORMAT(
      'ALTER TABLE ONLY %1$I ADD CONSTRAINT %1$s__pkey PRIMARY KEY (id);'
      , partition_table_name);
    EXECUTE FORMAT(
      'CREATE INDEX %1$s__created_at ON %1$I (created_at);'
      , partition_table_name);
  END IF;
  EXECUTE FORMAT('INSERT INTO %I VALUES ($1.*)', partition_table_name) USING NEW;

  RETURN NULL;
END;
$$
LANGUAGE plpgsql;
В данном шаге на основе входных данных определяем имя партиции, к которой должны относится новые данные, и условия принадлежности к этой партиции (первые три строки блока BEGIN). Проверяем существование такой партиции (TO_REGCLASS), и если её нет — создаём соответствующую партицию и индексы к ней (EXECUTE FORMAT … CREATE TABLE, ALTER TABLE, CREATE INDEX). В конце вставляем новые данные в правильную партицию. Соответственно, если партиция существует, то просто вставляем в неё новые данные.

2. Подключаем функцию к мастер-таблице.

3. Разносим данные из мастер-таблицы по партициям.

4. Очищаем мастер-таблицу.

Таким образом, 

вместо 6 шагов процедура сократилась до 4;

нет необходимости в периодическом ручном, либо полуавтоматическом (через cron) создании партиций;

функция существенно упростилась (да, всё так: 100 if’ов для каждой партиции против одного if’а на проверку существования партиции — это значительное упрощение);

изменение функции требуется только при изменении схемы мастер-таблицы.

Может показаться, что функция усложнилась, появились переменные, выполняются дополнительные шаги по идентификации имени и созданию партиции — это же всё очень медленно. Но, во-первых, партиции создаются не каждую секунду, эта операция фактически выполняется раз в месяц (в случае помесячного разбиения). Во-вторых, как далее будет видно на примерах, даже вставка данных легко может быть ускорена, несмотря на дополнительные накладные расходы.
